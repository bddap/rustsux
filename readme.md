# A list of things I dislike about Rust

## derive(Clone) is not reliable

Trait bounds for generic types are generated incorrectly. For example:

```rust
#[derive(Clone)]
struct Foo<T> {
	inner: PhantomData<T>,
}
```

The generated code unnecesarily requires `T` to be clone. `PhantomData<T>` is the what should be required to implement clone in this case.

What's worse, when `T` is not Clone, the derive fails silently. Rustc won't emit any errors until a `.clone()` is called on a `Foo` object.
The silent errors are confusing, and end up wasting a lot of time.

https://github.com/rust-lang/rust/issues/26925

## `cargo check` does not check doctests

Maybe this is intentional, but is catches me off gaurd occasionally.

## negative trait bounds are not implemented

The following code is not currently possible:

```rust
trait CheckSend {
	fn is_send() -> bool;
}

impl<T: Send> CheckSend for T {
	fn is_send() -> bool {
		true
	}
}

impl<T: !Send> CheckSend for T {
	fn is_send() -> bool {
		false
	}
}
```

## Coherence rules

I understand they are necessary, but they sure are a pain sometimes.

Example: crate `A` defines a trait `Ta`. Crate `A` wants to provide a macro to implement `Ta` for any type `T` that implements trait `Tb` where `Tb` is defined in client crate `B`.

This does not work:

```rust
impl<T: Tb> Ta for T { ... }
```

The reason that doesn't work: the impl is generated by a macro, so rustc counts it as being part of the crate `B`.
Due to coherence rules the only place this impl would be allowed is crate `A`.

Crate `A` does in fact define the impl, but rustc doesn't know that. Frustrating.

I ran into this issue lately. My hacky solution was to `impl Ta for &dyn T { ... }`, which adds some runtime overhead because dynamic dispatch.
Calling a `Ta` method also becomes a hassle: `foo.method()` becomes `(&foo as &dyn Tb).method()`.

## Enums variants are not standalone types

I see this pattern all the time.

```rust
enum Foo {
	Bar(Bar),
	Baz(Baz),
}

enum Bar {
	A,
	B,
}

struct Baz {
	a: bool,
	b: usize,
}

let bar: Bar = Bar::A;
let baz: Baz  = Baz { a: false, b: 0 };
let foo: Foo = Foo::Bar(Bar::A);
```

See the boilerplate/repetition?. `Bar(Bar)` smells bad.


```rust
enum Foo {
	Bar {
		A,
		B,
	},
	Baz {
		a: bool,
		b: usize,
	},
}

let bar: Foo::Bar = Foo::Bar::A;
let baz: Foo::Baz = Foo::Baz { a: false, b: 0 };
let foo: Foo = Foo::Bar(Foo::Bar::A);
```

The latter example reduces the number of required type definitions. It feels pretty ergonomic too.
