# A list of things I dislike about Rust

## derive(Clone) is not reliable

Trait bounds for generic types are generated incorrectly. For example:

```rust
#[derive(Clone)]
struct Foo<T> {
	inner: PhantomData<T>,
}
```

The generated code unnecesarily requires `T` to be clone. `PhantomData<T>` is the what should be required to implement clone in this case.

What's worse, when `T` is not Clone, the derive fails silently. Rustc won't emit any errors until a `.clone()` is called on a `Foo` object.
The silent errors are confusing, and end up wasting a lot of time.

https://github.com/rust-lang/rust/issues/26925

## `cargo check` does not check doctests

Maybe this is intentional, but is catches me off gaurd occasionally.

## negative trait bounds are not implemented

The following code is not currently possible:

```rust
trait CheckSend {
	fn is_send() -> bool;
}

impl<T: Send> CheckSend for T {
	fn is_send() -> bool {
		true
	}
}

impl<T: !Send> CheckSend for T {
	fn is_send() -> bool {
		false
	}
}
```

## Coherence rules

I understand they are necessary, but they sure are a pain sometimes.

Example: crate `A` defines a trait `Ta`. Crate `A` wants to provide a macro to implement `Ta` for any type `T` that implements trait `Tb` where `Tb` is defined in client crate `B`.

This does not work:

```rust
impl<T: Tb> Ta for T { ... }
```

The reason that doesn't work: the impl is generated by a macro, so rustc counts it as being part of the crate `B`.
Due to coherence rules the only place this impl would be allowed is crate `A`.

Crate `A` does in fact define the impl, but rustc doesn't know that. Frustrating.

I ran into this issue lately. My hacky solution was to `impl Ta for &dyn T { ... }`, which adds some runtime overhead because dynamic dispatch.
